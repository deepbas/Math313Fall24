{
  "hash": "72d1535ed29ca8de4113c0f194e70894",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 28\"\ntitle-slide-attributes:\n  data-background-image: images/lake.jpg\n  data-background-size: contain\n  data-background-opacity: \"0.5\"\nsubtitle: \"MATH 313: Survey Design and Sampling\"\nauthor: \"Bastola\"\nformat:\n  revealjs:\n    html-math-method: mathjax\n    mathjax-url: \"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/MathJax.js\"\n    theme: [default, scss/main.scss]\n    slide_level: 2\n    slide-number: true\n    preview-links: auto\n    history: true\n    chalkboard: \n      src: chalkboard.json\n      eraser:\n        src: 'img/sponge.png'\n        radius: 20\n    transition: slide\n    background-transition: fade    \n    touch: false\n    controls: true\n---\n\n\n\n\n\n\n## Comprehensive Guide to Cluster Sampling {.font80}\n\n::: cle7\n**Cluster Sampling** emerges as a cost-effective and efficient sampling design, particularly advantageous in scenarios where a full listing of population elements is impractical or overly expensive. This sampling method is instrumental in gathering substantial information with minimized resource expenditure.\n:::\n\n## Key Concepts and Benefits {.font80}\n::: cle6\n- **Cost Reduction:** By sampling clusters (e.g., city blocks or regions), rather than individual units (e.g., households), significant savings on logistical and operational costs are achieved, especially when geographical dispersion of the population elements is a factor.\n- **Feasibility:** The necessity for a detailed frame listing all elements is circumvented, allowing for practical implementation in large-scale surveys or studies.\n:::\n\n## Implementation Steps in Cluster Sampling {.font60}\n\n::: cle6\nCluster sampling involves several key steps, each critical to the success of the sampling strategy. These steps are defined with precise terminology to ensure clarity and accuracy.\n\n1. **Identify Clusters:** Divide the population into natural clusters, referred to as $M$, where $M$ is the total number of clusters in the population.\n\n2. **Determine Sample Size:** Decide on the number of clusters, $m$, to sample randomly. Each cluster $i$ contains $n_i$ elements, contributing to the determination of cluster sizes.\n\n3. **Random Selection:** Randomly select $m$ clusters from the population. This step ensures that each cluster has an equal chance of being included in the sample.\n\n4. **Data Collection:** Collect data from every element within each chosen cluster. The total number of observations within the $i^{th}$ cluster is represented by $\\tau_i$, and each observation in the cluster is indexed by $j$ (denoted $y_{i j}$).\n\n5. **Statistical Calculation:** Calculate the average cluster size for the sample as $\\frac{1}{m} \\cdot \\sum_{i=1}^m n_i$, and for the population as $\\bar{N} = \\frac{N}{M}$, where $N = \\sum_{i=1}^M n_i$ represents the total population size.\n:::\n\n\n\n## Design Considerations {.font80}\n::: cle5\n- **Cluster Homogeneity:** Unlike strata, which should be as homogeneous as possible to minimize variance within each stratum, clusters should be internally heterogeneous but similar to each other to maximize the representativeness of the sample. This configuration enhances the accuracy of the estimates derived from the sample.\n:::\n\n## Practical Application Example {.font80}\nImagine estimating the average income per household in a large city. Cluster sampling allows selecting city blocks as clusters and surveying every household within those blocks, thereby reducing the cost and complexity of the sampling process.\n\n## Strategic Advantages {.font80}\n::: cle7\n- **Reduced Travel Expenses:** By concentrating the survey within geographical clusters, travel time and related costs for surveyors are significantly lowered.\n- **Ease of Sampling:** Using a frame that lists clusters (like city blocks), rather than individual households, simplifies the sampling process and enhances operational efficiency.\n\nThis method not only aligns with the objectives of minimizing costs and simplifying logistics but also adapts flexibly to various survey environments, proving essential for researchers and organizations aiming for efficient data collection strategies.\n\n:::\n\n## Estimating the Population Mean with Cluster Sampling {.font60}\n\n::: cle7\nThe population mean, $\\mu$, is estimated using a ratio estimator derived from sampled clusters. This approach leverages the proportional representation of each cluster to approximate the overall population mean.\n\n### **Ratio Estimator Formula**\n$$\n\\bar{y} = \\frac{\\sum_{i=1}^{m} \\tau_i}{\\sum_{i=1}^{m} n_i}\n$$\nwhere $\\tau_i$ is the total of all observations within the $i^{th}$ cluster, and $n_i$ is the number of elements in the $i^{th}$ cluster.\n:::\n\n## Calculation of Variance in Cluster Sampling {.font70}\n\n::: cle7\nEstimating the variance of the population mean estimator is critical for assessing the precision of the sampling strategy.\n\n### **Variance Formula**\nThe estimated variance of the mean estimator $\\bar{y}$ is given by:\n$$\n\\hat{V}(\\bar{y}) = \\left(1-\\frac{m}{M}\\right) \\frac{s_{\\mathrm{r}}^2}{m\\bar{N}^2}\n$$\nwhere $s_{\\mathrm{r}}^2 = \\frac{\\sum_{i=1}^m\\left(\\tau_i-\\bar{y} n_i\\right)^2}{m-1}$ is the residual sum of squares from the ratio estimation.\n:::\n\n## Confidence Intervals for Cluster Sampling {.font70}\n\n::: cle7\nConstructing a confidence interval around $\\bar{y}$ helps quantify the uncertainty of our estimate.\n\n### **Normal Approximation**\nFor sufficiently large $m$, typically $m > 20$, the sampling distribution of $\\bar{y}$ can be approximated by a normal distribution, facilitating the computation of confidence intervals.\n\n### **Confidence Interval Calculation**\n$$\n\\bar{y} \\pm z \\cdot \\sqrt{\\hat{V}(\\bar{y})}\n$$\nwhere $z$ is the z-score corresponding to the desired confidence level (e.g., 1.96 for 95% confidence).\n:::\n\n## {.font40}\n\n> Example 1: A sociologist wants to estimate the per-capita income in a certain small city. No list of resi-\ndent adults is available. So she performed cluster sampling. The city is marked off into rectangular blocks,\nexcept for two industrial areas and three parks that contain only a few houses. The sociologist decides\nthat each of the city blocks will be considered one cluster, the two industrial areas will be considered one\ncluster, and finally, the three parks will be considered one cluster. The clusters are numbered on a city\nmap, with the numbers from 1 to 415.The experimenter has enough time and money to sample clusters\nand to interview every household within each cluster. Hence, 25 random numbers between1 and 415 are\nselected, and the clusters having these numbers are marked on the map.Interviewers are then assigned to\neach of the sampled clusters. The data on incomes are presented in the following. Use the data to estimate\nthe per-capita income in the city and place a bound on the error of estimation.\n\n\n<img src=\"images/Day28-1.png\" style=\"display: block; margin: auto;\" width=\"80%\"  loading=\"lazy\" decoding=\"async\">\n\n\n##\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}