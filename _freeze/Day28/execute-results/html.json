{
  "hash": "127c6c91eff8a289942ec18556aa5681",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 28\"\ntitle-slide-attributes:\n  data-background-image: images/lake.jpg\n  data-background-size: contain\n  data-background-opacity: \"0.5\"\nsubtitle: \"MATH 313: Survey Design and Sampling\"\nauthor: \"Bastola\"\nformat:\n  revealjs:\n    html-math-method: mathjax\n    mathjax-url: \"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/MathJax.js\"\n    theme: [default, scss/main.scss]\n    slide_level: 2\n    slide-number: true\n    preview-links: auto\n    history: true\n    chalkboard: \n      src: chalkboard.json\n      eraser:\n        src: 'img/sponge.png'\n        radius: 20\n    transition: slide\n    background-transition: fade    \n    touch: false\n    controls: true\n---\n\n\n\n\n\n\n## Comprehensive Guide to Cluster Sampling {.font80}\n\n::: cle7\n**Cluster Sampling** emerges as a cost-effective and efficient sampling design, particularly advantageous in scenarios where a full listing of population elements is impractical or overly expensive. This sampling method is instrumental in gathering substantial information with minimized resource expenditure.\n:::\n\n## Key Concepts and Benefits {.font80}\n::: cle6\n- **Cost Reduction:** By sampling clusters (e.g., city blocks or regions), rather than individual units (e.g., households), significant savings on logistical and operational costs are achieved, especially when geographical dispersion of the population elements is a factor.\n- **Feasibility:** The necessity for a detailed frame listing all elements is circumvented, allowing for practical implementation in large-scale surveys or studies.\n:::\n\n## Implementation Steps {.font80}\n::: cle6\n1. **Identify Clusters:** Divide the population into natural clusters.\n2. **Determine Sample Size:** Set the number of clusters, $n$, and cluster size, $m_i$ (the number of elements in cluster $i$).\n3. **Random Selection:** Randomly choose $n$ clusters from the population.\n4. **Data Collection:** Gather data from every element within each chosen cluster, ensuring comprehensive coverage.\n:::\n\n\n## Design Considerations {.font80}\n::: cle5\n- **Cluster Homogeneity:** Unlike strata, which should be as homogeneous as possible to minimize variance within each stratum, clusters should be internally heterogeneous but similar to each other to maximize the representativeness of the sample. This configuration enhances the accuracy of the estimates derived from the sample.\n:::\n\n## Practical Application Example {.font80}\nImagine estimating the average income per household in a large city. Cluster sampling allows selecting city blocks as clusters and surveying every household within those blocks, thereby reducing the cost and complexity of the sampling process.\n\n## Strategic Advantages {.font80}\n::: cle7\n- **Reduced Travel Expenses:** By concentrating the survey within geographical clusters, travel time and related costs for surveyors are significantly lowered.\n- **Ease of Sampling:** Using a frame that lists clusters (like city blocks), rather than individual households, simplifies the sampling process and enhances operational efficiency.\n\nThis method not only aligns with the objectives of minimizing costs and simplifying logistics but also adapts flexibly to various survey environments, proving essential for researchers and organizations aiming for efficient data collection strategies.\n\n:::\n\n## Estimating the Population Mean with Cluster Sampling {.font60}\n\n::: cle7\nIn cluster sampling, the estimation of the population mean $\\mu$ is performed using a ratio estimator based on sampled clusters. This method allows us to approximate the overall population mean by leveraging the proportional representation of each cluster.\n\n### **Notations and Definitions**\n- $M$: Total number of clusters in the population.\n- $m$: Number of clusters selected in the sample.\n- $n_i$: Number of elements in the $i^{th}$ cluster.\n- $\\bar{y}$: Ratio estimator for the population mean.\n\n### **Ratio Estimator Formula**\nThe population mean $\\mu$ is estimated using the following ratio:\n$$\n\\bar{y}=\\frac{\\sum_{i=1}^{m} \\tau_i}{\\sum_{i=1}^{m} n_i}\n$$\nwhere $\\tau_i$ is the total of all observations within the $i^{th}$ cluster.\n:::\n\n## Variance and Confidence Interval for $\\bar{y}$ {.font70}\n\n::: cle7\nUnderstanding the variability and confidence of our estimate is crucial. The estimated variance of $\\bar{y}$ and the confidence interval provide insights into the precision of our estimate.\n\n### **Estimated Variance of $\\bar{y}$**\nThe variance of $\\bar{y}$ gives us an idea of how much the estimated mean might vary from sample to sample.\n\n### **Confidence Interval**\nWhen the number of clusters $m > 20$, $\\bar{y}$ can be assumed to follow a normal distribution, allowing us to construct a confidence interval:\n$$\n\\bar{y} \\pm B\n$$\nwhere $B$ is the bound on the error of estimation.\n:::\n\n## {.font40}\n\n> Example 1: A sociologist wants to estimate the per-capita income in a certain small city. No list of resi-\ndent adults is available. So she performed cluster sampling. The city is marked off into rectangular blocks,\nexcept for two industrial areas and three parks that contain only a few houses. The sociologist decides\nthat each of the city blocks will be considered one cluster, the two industrial areas will be considered one\ncluster, and finally, the three parks will be considered one cluster. The clusters are numbered on a city\nmap, with the numbers from 1 to 415.The experimenter has enough time and money to sample clusters\nand to interview every household within each cluster. Hence, 25 random numbers between1 and 415 are\nselected, and the clusters having these numbers are marked on the map.Interviewers are then assigned to\neach of the sampled clusters. The data on incomes are presented in the following. Use the data to estimate\nthe per-capita income in the city and place a bound on the error of estimation.\n\n\n<img src=\"images/Day28-1.png\" style=\"display: block; margin: auto;\" width=\"80%\"  loading=\"lazy\" decoding=\"async\">\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}